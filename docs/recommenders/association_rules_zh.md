# 2.3 关联规则挖掘推荐方法

## 2.3.1 原理

关联规则挖掘是一种基于规则的数据挖掘方法，用于在大型数据库中发现变量之间的有趣关系。在电影推荐的背景下，关联规则能够识别用户行为中的模式，并发现诸如"喜欢电影 A 的用户也喜欢电影 B"这样的关系。

## 2.3.2 理论框架

### 形式化定义
设 \( I = \{i_1, i_2, ..., i_n\} \) 是一个包含 \( n \) 个二元属性的集合，这些元素被称为物品（在电影推荐场景中即指电影）。设 \( D = \{t_1, t_2, ..., t_m\} \) 是用户行为记录的集合。每条记录包含物品集合 \( I \) 中的一个子集，并具有唯一标识符。

规则被定义为一种蕴含关系的形式：
\[ X \rightarrow Y \]

其中 \( X, Y \subseteq I \) 且 \( X \cap Y = \emptyset \)。\( X \) 被称为规则的前提或左部（LHS），而 \( Y \) 被称为结论或右部（RHS）。

关联规则的质量通常由三个关键指标来衡量：

1. **支持度(Support)**: 表示规则 \( X \rightarrow Y \) 在所有事务中出现的频率。
   \[ \text{Support}(X \rightarrow Y) = \frac{\text{包含}X\text{和}Y\text{的事务数}}{\text{总事务数}} = P(X \cup Y) \]

2. **置信度(Confidence)**: 表示包含 \( X \) 的事务中同时包含 \( Y \) 的比例。
   \[ \text{Confidence}(X \rightarrow Y) = \frac{\text{Support}(X \cup Y)}{\text{Support}(X)} = P(Y|X) \]

3. **提升度(Lift)**: 衡量规则的相关性，表示 \( X \) 和 \( Y \) 一起出现的频率与它们独立出现的频率之比。
   \[ \text{Lift}(X \rightarrow Y) = \frac{\text{Confidence}(X \rightarrow Y)}{\text{Support}(Y)} = \frac{P(X \cup Y)}{P(X) \times P(Y)} \]

提升度大于1表示正相关，等于1表示独立，小于1表示负相关。

## 2.3.3 FP-Growth算法详解

FP-Growth（频繁模式增长）算法通过构建FP树（Frequent Pattern Tree）这种压缩数据结构，显著改进了传统关联规则挖掘方法：

### 算法基本原理

1. **数据压缩**：将原始用户行为记录压缩到树形结构中
2. **模式生长**：通过递归方式挖掘频繁模式，避免产生中间候选集

### FP树的构建过程

**第一次扫描**：
- 统计各电影的出现频次
- 过滤低于最小支持度的冷门电影
- 生成按频率排序的「高频电影列表」

**第二次扫描**：
- 对每条用户观影记录进行预处理：
  1. 移除非高频电影
  2. 按「高频电影列表」顺序重新排列
- 将处理后的记录插入FP树


### 频繁项集的挖掘过程
从项头表底部开始，针对每个电影：
1. 收集所有包含该电影的前缀路径
2. 构建条件模式基（Conditional Pattern Base）
3. 递归生成条件FP树


### FP-Growth与Apriori算法的对比

FP-Growth算法与Apriori算法在挖掘频繁项集方面有显著的区别，它们各有优缺点：

| 特性                | FP-Growth                      | Apriori                        |
|---------------------|--------------------------------|--------------------------------|
| 数据库扫描次数       | 2次                            | 与最长频繁模式长度成正比        |
| 内存效率            | 通过前缀共享优化存储           | 存在候选项集爆炸风险            |

FP-Growth算法的主要优势在于：

1. **计算效率**：通过避免生成候选项集和减少数据库扫描次数，FP-Growth在大多数情况下比Apriori快几个数量级
2. **内存效率**：FP树通过前缀共享压缩数据，减少了存储冗余
3. **可扩展性**：能够处理更大规模的数据集和更长的频繁模式

对于电影推荐这类可能涉及数百万用户和数千部电影的应用场景，FP-Growth的这些优势尤为重要，使其成为实际应用中的首选算法。

## 2.3.4 在电影推荐中的应用

### 构建事务
将用户评分数据转化为二元关系：
- 当用户对电影的评分 $ \geq 6 $（10分制）时视为「喜欢」
- 每个用户的「喜欢」电影集合构成一条事务记录

对于用户 \( u \) 和所有电影集合 \( M \)，事务 \( t_u \) 定义为：

\[ t_u = \{m \in M \mid \text{rating}(u, m) \geq \text{threshold}\} \]

这种方式将评分数据转化为二元关系（喜欢/不喜欢），简化了关联规则的挖掘过程。

### 规则解释

在这种背景下发现的规则 \( A \rightarrow B \) 表明，喜欢集合 \( A \) 中电影的用户也倾向于喜欢集合 \( B \) 中的电影。这种倾向的强度通过规则的置信度和提升度来衡量。

例如，规则 \{复仇者联盟\} → \{钢铁侠\} 表示喜欢复仇者联盟的用户也倾向于喜欢钢铁侠。如果这条规则的置信度为0.8，则表示80%喜欢复仇者联盟的用户也喜欢钢铁侠；如果提升度为2.0，则表示用户同时喜欢这两部电影的概率是随机情况下的2倍，证明它们之间有很强的正相关性。

### 推荐生成流程

为了给喜欢电影 \( m \) 的用户生成推荐，我们执行以下步骤：

1. 找出所有以 \( \{m\} \) 为前提的关联规则 \( \{m\} \rightarrow Y \)
2. 按照置信度或提升度对这些规则进行排序
3. 从排序后的规则中提取电影作为推荐结果
4. 去除用户已经看过的电影
5. 返回前K个推荐结果

数学上，电影 \( m \) 的推荐集合 \( R \) 表示为：

\[ R(m) = \{n \in \bigcup_{r \in \mathcal{R}_m} \text{consequent}(r) \mid n \neq m\} \]

其中 \( \mathcal{R}_m \) 是前提为 \( m \) 的规则集合。

